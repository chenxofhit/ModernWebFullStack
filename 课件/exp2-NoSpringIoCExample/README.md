# 不使用Spring IoC的典型示例

这个项目展示了在不使用Spring IoC容器的情况下，Java应用程序如何管理依赖关系，以及这种方式的局限性。

## 项目结构

```
src/com/example/
├── UserDao.java               - 用户数据访问接口
├── UserDaoImpl.java           - 标准数据库实现
├── UserDaoMongoImpl.java      - MongoDB实现
├── UserService.java           - 用户服务接口
├── UserServiceImpl.java       - 硬编码依赖的服务实现
├── BetterUserServiceImpl.java - 使用工厂的服务实现
├── UserController.java        - 控制器类
├── DaoFactory.java            - DAO工厂类
├── NoIoCApplication.java      - 展示硬编码依赖的应用
└── FactoryApplication.java    - 展示工厂模式的应用
```

## 示例运行方法

编译并运行以下两个主类来观察不同依赖管理方式的区别：

1. 运行 `NoIoCApplication` 观察硬编码依赖的情况
2. 运行 `FactoryApplication` 观察使用工厂模式改进后的情况

## 问题与局限性

不使用Spring IoC的应用程序存在以下问题：

1. **硬编码依赖**：组件直接创建其依赖项，导致高度耦合
2. **难以切换实现**：无法轻松更换依赖的具体实现
3. **单元测试困难**：因为无法注入测试替身，难以进行隔离测试
4. **对象职责不单一**：每个组件除了自身功能外，还要负责创建和管理其依赖
5. **配置分散**：依赖关系和配置分散在代码各处，难以集中管理

## 手动改进尝试

在 `FactoryApplication` 中，我们尝试使用工厂模式来改进依赖管理，但仍存在以下局限：

1. 已创建的对象无法感知实现变化
2. 工厂类数量会随着应用程序规模增长而膨胀
3. 依赖关系仍然分散在代码中
4. 对象生命周期管理困难
5. 缺乏AOP等高级特性支持

## 对比Spring IoC的优势

Spring IoC通过以下方式解决上述问题：

1. **依赖注入**：组件不创建依赖，而是由容器注入
2. **松散耦合**：组件只依赖接口，不依赖具体实现
3. **集中配置**：依赖关系在配置文件或注解中集中管理
4. **生命周期管理**：容器统一管理对象的创建和销毁
5. **可测试性**：便于注入模拟对象进行单元测试
6. **支持AOP**：提供横切关注点的模块化支持 